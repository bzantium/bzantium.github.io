---
layout: post
title: "[LeetCode] 121. Best Time to Buy and Sell Stock"
subtitle: 
date: 2023-02-07
background: '/img/posts/code.jpg'
---

<h3>Problem:</h3>
<p>
You are given an array prices where `prices[i]` is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
</p>

```
Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

Example 2:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

```
Constraints:
1 <= prices.length <= 10^5
0 <= prices[i] <= 10^4
```

<br/>
<h3>Solution:</h3>
<p>1. Brute Force 방법</p>

<p>
먼저 가장 간단한 방법으로 앞에서부터 순서대로 모든 경우의 수를 시도해보는 것이다. 두 번째 예시에서 보면, 
<br/><br/>
3 + 2 = 5 -> x
<br/>
3 + 4 = 7 -> x
<br/>
2 + 4 = 6 -> o
<br/><br/>
와 같이 두 개의 for 문을 도는 방법으로, $O(n^2)$의 time complexity를 가진다.
</p>

<p>2. HashMap을 이용한 방법</p>

<p>
HashMap (Python Dictionary)을 사용했을 때 search time이 평균적으로 O(1)인 점을 이용하면 O(n)의 time complexity로 문제를 해결할 수 있다.
문제가 두 수의 합이 주어진 target과 일치하는 것을 찾는 것이므로 한 수가 주어졌을 때 target에서 값을 빼면 다른 한 값을 찾을 수 있다.
예를 들어, nums = [11,2,7,15], target = 9 라고 하자. 왼쪽에서 오른쪽으로 순서대로 하나씩 숫자를 검토한다고 할 때, 첫 번째 값은 11이다.
따라서 HashMap에 map = {11: 0} 와 같이 저장한다. 두 번째 값은 2인데 9 - 2 = 7 이므로 7이 map의 key 값에 존재하는지 체크하고 없으면 추가한다. (map = {11: 0, 2: 1})
다음 수는 7이며 같은 방식으로 9 - 7 = 2 값이 map의 key값들 안에 존재하는지 확인하면 존재하므로, 현재 인덱스와 map의 2번 key에 해당하는 value 값을 return해주면 된다.
</p>

<br/>
<h3>Code:</h3>

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {}
        
        for i, n in enumerate(nums):
            diff = target - n
            if prevMap.get(diff):
                return [prevMap[diff], i]
            prevMap[n] = i
        return
```
